// Generated by CoffeeScript 1.4.0
(function() {

  define(['systems/combat', 'systems/world', 'entity', 'entities', 'assemblages/assemblages'], function(Combat, World, Entity, Entities, Assemblages) {
    return describe('Combat System', function() {
      it('should exist', function() {
        var a;
        a = new Combat();
        return a.should.not.equal(void 0);
      });
      describe('getNeighbors(): Calculate neighbors properly', function() {
        var combat, entities, entityHuman, entityZombie, entityZombie2, world;
        entityHuman = Assemblages.human();
        entityZombie = Assemblages.zombie();
        entityZombie2 = Assemblages.zombie();
        entities = new Entities().add(entityHuman).add(entityZombie).add(entityZombie2);
        entityHuman.components.position.x = 10;
        entityHuman.components.position.y = 10;
        entityZombie.components.position.x = 10;
        entityZombie.components.position.y = 11;
        entityZombie2.components.position.x = 40;
        entityZombie2.components.position.y = 40;
        world = new World(entities);
        world.tick();
        combat = new Combat(entities);
        it('should return no neighbors when range is 0', function() {
          var humanCombat;
          humanCombat = entityHuman.components.combat;
          humanCombat.range = 0;
          return combat.getNeighbors(entityHuman).should.deep.equal({
            zombie: [],
            human: []
          });
        });
        it('should return 1 zombie neighbors when range is 1', function() {
          var humanCombat;
          world.tick();
          humanCombat = entityHuman.components.combat;
          humanCombat.range = 1;
          return combat.getNeighbors(entityHuman).should.deep.equal({
            zombie: [entityZombie.id],
            human: []
          });
        });
        return it('should return 2 zombie neighbors when range is 50', function() {
          var humanCombat;
          world.tick();
          humanCombat = entityHuman.components.combat;
          humanCombat.range = 50;
          return combat.getNeighbors(entityHuman).should.deep.equal({
            zombie: [entityZombie.id, entityZombie2.id],
            human: []
          });
        });
      });
      describe('Combat System: getDamage', function() {
        var combat, entities, entityHuman, entityZombie, humanCombat, zombieCombat;
        entityHuman = Assemblages.human();
        entityZombie = Assemblages.zombie();
        entityHuman.components.position.x = 10;
        entityHuman.components.position.y = 10;
        entityZombie.components.position.x = 10;
        entityZombie.components.position.y = 11;
        entities = new Entities().add(entityHuman).add(entityZombie);
        combat = new Combat(entities);
        humanCombat = entityHuman.components.combat;
        zombieCombat = entityZombie.components.combat;
        it('should return proper damage (attack > defense)', function() {
          var damage;
          humanCombat.attack = 2;
          zombieCombat.defense = 1;
          damage = combat.calculateDamage(humanCombat, zombieCombat);
          return damage.should.equal(1);
        });
        it('should return proper damage (attack === defense)', function() {
          var damage;
          humanCombat.attack = 1;
          zombieCombat.defense = 1;
          damage = combat.calculateDamage(humanCombat, zombieCombat);
          return damage.should.equal(0);
        });
        it('should return proper damage (attack much > defense)', function() {
          var damage;
          humanCombat.attack = 10;
          zombieCombat.defense = 0;
          damage = combat.calculateDamage(humanCombat, zombieCombat);
          return damage.should.equal(10);
        });
        return it('should return proper damage (defense > attack)', function() {
          var damage;
          humanCombat.attack = 0;
          zombieCombat.defense = 10;
          damage = combat.calculateDamage(humanCombat, zombieCombat);
          return damage.should.equal(0);
        });
      });
      describe('Combat System: fight()', function() {
        var combat, entities, entityHuman, entityZombie, humanCombat, humanHealth, zombieCombat, zombieHealth;
        entityHuman = Assemblages.human();
        entityZombie = Assemblages.zombie();
        zombieHealth = entityZombie.components.health;
        humanHealth = entityZombie.components.health;
        entityHuman.components.position.x = 10;
        entityHuman.components.position.y = 10;
        entityHuman.components.health.health = 100;
        entityHuman.components.combat.attack = 10;
        entityHuman.components.combat.defense = 5;
        entityHuman.components.combat.attackDelay = 4;
        entityZombie.components.position.x = 10;
        entityZombie.components.position.y = 11;
        entityZombie.components.health.health = 100;
        entityZombie.components.combat.attack = 15;
        entityZombie.components.combat.defense = 2;
        entityZombie.components.combat.attackDelay = 2;
        entities = new Entities().add(entityHuman).add(entityZombie);
        combat = new Combat(entities);
        humanCombat = entityHuman.components.combat;
        zombieCombat = entityZombie.components.combat;
        it('should properly fight human vs zombie and update delay', function() {
          humanCombat.canAttack.should.be["true"];
          zombieCombat.canAttack.should.be["true"];
          humanCombat.attackCounter.should.equal(0);
          combat.fight(entityHuman, entityZombie);
          humanCombat.canAttack.should.be["false"];
          zombieCombat.canAttack.should.be["true"];
          zombieHealth.health.should.equal(92);
          return humanCombat.attackCounter.should.equal(humanCombat.attackDelay + 1);
        });
        it('should not let human attack yet, update delay', function() {
          humanCombat.attackCounter.should.equal(humanCombat.attackDelay + 1);
          humanCombat.canAttack.should.be["false"];
          combat.updateAttackCounter(humanCombat);
          humanCombat.attackCounter.should.equal(4);
          return humanCombat.canAttack.should.be["false"];
        });
        it('should not execute fight() if canAttack is false', function() {
          return combat.fight(entityHuman, entityZombie).should.be["false"];
        });
        it('should update attack counter', function() {
          combat.updateAttackCounter(humanCombat);
          humanCombat.attackCounter.should.equal(3);
          return humanCombat.canAttack.should.be["false"];
        });
        it('should update again', function() {
          combat.updateAttackCounter(humanCombat);
          humanCombat.attackCounter.should.equal(2);
          return humanCombat.canAttack.should.be["false"];
        });
        it('and update again', function() {
          combat.updateAttackCounter(humanCombat);
          humanCombat.attackCounter.should.equal(1);
          return humanCombat.canAttack.should.be["false"];
        });
        return it('should equal 0 and allow attacking', function() {
          combat.updateAttackCounter(humanCombat);
          humanCombat.attackCounter.should.equal(0);
          humanCombat.canAttack.should.be["true"];
          combat.updateAttackCounter(humanCombat);
          humanCombat.attackCounter.should.equal(0);
          return humanCombat.canAttack.should.be["true"];
        });
      });
      return describe('Combat System: tick()', function() {
        var combat, entities, entityHuman, entityZombie, humanCombat, humanHealth, world, zombieCombat, zombieHealth;
        entityHuman = Assemblages.human();
        entityZombie = Assemblages.zombie();
        zombieHealth = entityZombie.components.health;
        humanHealth = entityZombie.components.health;
        entityHuman.components.position.x = 10;
        entityHuman.components.position.y = 10;
        entityHuman.components.health.health = 100;
        entityHuman.components.combat.attack = 10;
        entityHuman.components.combat.defense = 5;
        entityHuman.components.combat.attackDelay = 4;
        entityZombie.components.position.x = 10;
        entityZombie.components.position.y = 11;
        entityZombie.components.health.health = 100;
        entityZombie.components.combat.attack = 15;
        entityZombie.components.combat.defense = 2;
        entityZombie.components.combat.attackDelay = 2;
        entities = new Entities().add(entityHuman).add(entityZombie);
        combat = new Combat(entities);
        humanCombat = entityHuman.components.combat;
        zombieCombat = entityZombie.components.combat;
        world = new World(entities);
        world.tick();
        it('should fight both the human and zombie', function() {
          combat.tick(0);
          entityHuman.components.health.health.should.equal(90);
          humanCombat.canAttack.should.be["false"];
          entityZombie.components.health.health.should.equal(92);
          zombieCombat.canAttack.should.be["false"];
          humanCombat.attackCounter.should.equal(4);
          return zombieCombat.attackCounter.should.equal(2);
        });
        it('should not fight when tick is called again', function() {
          combat.tick(1);
          zombieCombat.canAttack.should.be["false"];
          humanCombat.canAttack.should.be["false"];
          entityHuman.components.health.health.should.equal(90);
          entityZombie.components.health.health.should.equal(92);
          humanCombat.attackCounter.should.equal(3);
          humanCombat.canAttack.should.be["false"];
          zombieCombat.attackCounter.should.equal(1);
          return zombieCombat.canAttack.should.be["false"];
        });
        it('should not fight when tick is called again again', function() {
          combat.tick(2);
          entityHuman.components.health.health.should.equal(90);
          entityZombie.components.health.health.should.equal(92);
          humanCombat.attackCounter.should.equal(2);
          humanCombat.canAttack.should.be["false"];
          zombieCombat.attackCounter.should.equal(0);
          return zombieCombat.canAttack.should.be["true"];
        });
        it('should allow zombie to attack (two ticks have gone by since first attack)', function() {
          combat.tick(3);
          entityHuman.components.health.health.should.equal(80);
          entityZombie.components.health.health.should.equal(92);
          humanCombat.attackCounter.should.equal(1);
          humanCombat.canAttack.should.be["false"];
          zombieCombat.attackCounter.should.equal(2);
          return zombieCombat.canAttack.should.be["false"];
        });
        it('should not fight, but ready to', function() {
          combat.tick(4);
          entityHuman.components.health.health.should.equal(80);
          entityZombie.components.health.health.should.equal(92);
          humanCombat.attackCounter.should.equal(0);
          humanCombat.canAttack.should.be["true"];
          zombieCombat.attackCounter.should.equal(1);
          return zombieCombat.canAttack.should.be["false"];
        });
        return it('should let human fight', function() {
          combat.tick(5);
          entityHuman.components.health.health.should.equal(80);
          entityZombie.components.health.health.should.equal(84);
          humanCombat.attackCounter.should.equal(4);
          humanCombat.canAttack.should.be["false"];
          zombieCombat.attackCounter.should.equal(0);
          return zombieCombat.canAttack.should.be["true"];
        });
      });
    });
  });

}).call(this);
