// Generated by CoffeeScript 1.4.0
(function() {

  define(['components/vector', 'systems/flocking', 'systems/world', 'components/world', 'entities', 'entity'], function(Vector, Flocking, World, WorldComponent, Entities, Entity) {
    return describe('Flocking System', function() {
      describe('flock() function', function() {
        return it('should update position after calling flock()', function() {
          var a, b, entities, flocking;
          entities = new Entities();
          a = new Entity();
          a.addComponent('position');
          a.addComponent('physics');
          a.addComponent('flocking');
          a.components.position.x = 4;
          a.components.position.y = 4;
          b = new Entity();
          b.addComponent('position');
          b.addComponent('physics');
          b.addComponent('flocking');
          b.components.position.x = 10;
          b.components.position.y = 10;
          entities.add(a);
          entities.add(b);
          flocking = new Flocking(entities);
          flocking.flock(a, entities.entitiesIndex.flocking);
          a.components.position.x.should.equal(4);
          return a.components.position.y.should.equal(4);
        });
      });
      describe('Flocking sub functions  - two entities', function() {
        var a, b, entities, flocking;
        entities = new Entities();
        a = new Entity();
        a.addComponent('position');
        a.addComponent('physics');
        a.addComponent('flocking');
        a.addComponent('world');
        a.addComponent('human');
        a.components.position.x = 4;
        a.components.position.y = 4;
        a.components.physics.velocity.x = 2;
        a.components.physics.velocity.y = 4;
        b = new Entity();
        b.addComponent('position');
        b.addComponent('physics');
        b.addComponent('flocking');
        b.addComponent('world');
        b.addComponent('human');
        b.components.position.x = 10;
        b.components.position.y = 10;
        b.components.physics.velocity.x = 4;
        b.components.physics.velocity.y = 8;
        entities.add(a).add(b);
        flocking = new Flocking(entities);
        describe('separate()', function() {
          it('separate should return proper values', function() {
            var force;
            force = flocking.separate(a, entities.entitiesIndex.flocking);
            force.x.should.equal(-4.970348660325108);
            return force.y.should.equal(-6.268622990322866);
          });
          return it('should return same values when neighbors from a grid are passed in', function() {
            var force, world;
            world = new World(entities);
            world.tick();
            force = flocking.separate(a, a.components.world.getNeighbors(20));
            force.x.should.equal(-4.970348660325108);
            return force.y.should.equal(-6.268622990322866);
          });
        });
        describe('cohesion()', function() {
          return it('cohesion should return proper values', function() {
            var force;
            force = flocking.cohesion(a, entities.entitiesIndex.flocking);
            force.x.should.equal(0.4996908008410636);
            return force.y.should.equal(0.017581341098348992);
          });
        });
        return describe('align()', function() {
          return it('align should return proper values', function() {
            var force;
            force = flocking.align(a, entities.entitiesIndex.flocking);
            force.x.should.equal(0.22360679774997896);
            return force.y.should.equal(0.4472135954999579);
          });
        });
      });
      return describe('Flocking sub functions  - multiply entities', function() {
        var a, b, c, d, e, entities, flocking;
        entities = new Entities();
        a = new Entity().addComponent('position').addComponent('physics').addComponent('flocking').addComponent('world').addComponent('human');
        a.components.position.x = 4;
        a.components.position.y = 4;
        a.components.physics.velocity.x = 2;
        a.components.physics.velocity.y = 4;
        b = new Entity().addComponent('position').addComponent('physics').addComponent('flocking').addComponent('human').addComponent('world');
        b.components.position.x = 10;
        b.components.position.y = 10;
        b.components.physics.velocity.x = 1;
        b.components.physics.velocity.y = 2;
        c = new Entity().addComponent('position').addComponent('physics').addComponent('flocking').addComponent('human').addComponent('world');
        c.components.position.x = 6;
        c.components.position.y = 8;
        d = new Entity().addComponent('position').addComponent('physics').addComponent('flocking').addComponent('human').addComponent('world');
        d.components.position.x = 2;
        d.components.position.y = 2;
        e = new Entity().addComponent('position').addComponent('physics').addComponent('flocking').addComponent('human').addComponent('world');
        e.components.position.x = 300;
        e.components.position.y = 300;
        e.components.physics.velocity.x = 4;
        e.components.physics.velocity.y = 7;
        entities.add(a).add(b).add(c).add(d);
        flocking = new Flocking(entities);
        describe('separate()', function() {
          it('separate should return proper values', function() {
            var force;
            force = flocking.separate(a, entities.entitiesIndex.flocking);
            force.x.should.equal(4.500017344982671);
            return force.y.should.equal(-6.614366477211186);
          });
          entities.add(e);
          it('adding far away entity should NOT modify values', function() {
            var force;
            force = flocking.separate(a, entities.entitiesIndex.flocking);
            force.x.should.equal(4.500017344982671);
            return force.y.should.equal(-6.614366477211186);
          });
          entities.remove(e);
          return it('should return same values when neighbors from a grid are passed in', function() {
            var force, world;
            WorldComponent.cellSize = 4;
            world = new World(entities);
            world.tick();
            force = flocking.separate(a, a.components.world.getNeighbors(1));
            force.x.should.equal(4.500017344982671);
            return force.y.should.equal(-6.614366477211186);
          });
        });
        describe('cohesion()', function() {
          it('cohesion should return proper values', function() {
            var force;
            force = flocking.cohesion(a, entities.entitiesIndex.flocking);
            force.x.should.equal(-0.2036416367602448);
            return force.y.should.equal(-0.45665094303812465);
          });
          entities.add(e);
          it('adding far away entity should NOT modify values', function() {
            var force;
            force = flocking.cohesion(a, entities.entitiesIndex.flocking);
            force.x.should.equal(-0.2036416367602448);
            return force.y.should.equal(-0.45665094303812465);
          });
          entities.remove(e);
          return it('should return same values when neighbors from a grid are passed in', function() {
            var force, world;
            WorldComponent.cellSize = 4;
            world = new World(entities);
            world.tick();
            force = flocking.cohesion(a, a.components.world.getNeighbors(1));
            force.x.should.equal(-0.2036416367602448);
            return force.y.should.equal(-0.45665094303812465);
          });
        });
        return describe('align()', function() {
          it('align should return proper values', function() {
            var force;
            force = flocking.align(a, entities.entitiesIndex.flocking);
            force.x.should.equal(0.22360679774997896);
            return force.y.should.equal(0.4472135954999579);
          });
          entities.add(e);
          it('adding far away entity should NOT modify values', function() {
            var force;
            force = flocking.align(a, entities.entitiesIndex.flocking);
            force.x.should.equal(0.22360679774997896);
            return force.y.should.equal(0.4472135954999579);
          });
          entities.remove(e);
          return it('should return same values when neighbors from a grid are passed in', function() {
            var force, world;
            WorldComponent.cellSize = 4;
            world = new World(entities);
            world.tick();
            force = flocking.align(a, a.components.world.getNeighbors(1));
            force.x.should.equal(0.22360679774997896);
            return force.y.should.equal(0.4472135954999579);
          });
        });
      });
    });
  });

}).call(this);
