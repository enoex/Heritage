// Generated by CoffeeScript 1.4.0
(function() {

  define([], function() {
    var Combat;
    Combat = (function() {

      function Combat(entities) {
        this.entities = entities;
        return this;
      }

      Combat.prototype.getNeighbors = function(entity) {
        var creatureType, neighbor, neighbors, world, _i, _len, _ref;
        neighbors = {
          zombie: [],
          human: []
        };
        world = entity.components.world;
        if (!world) {
          return neighbors;
        }
        _ref = world.getNeighbors(entity.components.combat.range);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          neighbor = _ref[_i];
          if (!neighbor.hasComponent('combat')) {
            continue;
          }
          if (neighbor.hasComponent('zombie')) {
            creatureType = 'zombie';
          } else if (neighbor.hasComponent('human')) {
            creatureType = 'human';
          }
          if (neighbor !== entity && creatureType) {
            neighbors[creatureType].push(neighbor);
          }
        }
        return neighbors;
      };

      Combat.prototype.updateAttackCounter = function(combat) {
        if (combat.attackCounter > 0) {
          combat.attackCounter -= 1;
        }
        if (combat.attackCounter <= 0) {
          combat.canAttack = true;
        }
        return combat.canAttack;
      };

      Combat.prototype.calculateDamage = function(combat, enemyCombat) {
        var damage;
        damage = 0;
        damage = combat.attack;
        damage -= enemyCombat.defense;
        if (damage < 0) {
          damage = 0;
        }
        return damage;
      };

      Combat.prototype.fight = function(entity, enemyEntity) {
        var damage, enemyCombat, entityCombat, health;
        entityCombat = entity.components.combat;
        enemyCombat = enemyEntity.components.combat;
        if (!entityCombat.canAttack) {
          return false;
        }
        if (!entityCombat || !enemyCombat) {
          return false;
        }
        damage = this.calculateDamage(entityCombat, enemyCombat);
        health = enemyEntity.components.health;
        if (health) {
          health.health -= damage;
        }
        entityCombat.canAttack = false;
        entityCombat.attackCounter = entityCombat.attackDelay + 1;
        return true;
      };

      Combat.prototype.tick = function(delta) {
        var combat, damageStack, entity, health, id, isHuman, isZombie, neighbors, targetEntity, targetGroup, _i, _len, _ref, _ref1;
        damageStack = [];
        _ref = this.entities.entitiesIndex['combat'];
        for (id in _ref) {
          entity = _ref[id];
          isHuman = entity.hasComponent('human');
          isZombie = entity.hasComponent('zombie');
          combat = entity.components.combat;
          if (combat.canAttack) {
            health = entity.components.health;
            neighbors = this.getNeighbors(entity);
            if (isHuman) {
              targetGroup = 'zombie';
            }
            if (isZombie) {
              targetGroup = 'human';
            }
            _ref1 = neighbors[targetGroup];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              targetEntity = _ref1[_i];
              this.fight(entity, targetEntity);
              break;
            }
          }
          this.updateAttackCounter(combat);
        }
        return this;
      };

      return Combat;

    })();
    return Combat;
  });

}).call(this);
